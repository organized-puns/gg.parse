using gg.parse.compiler;
using gg.parse.rulefunctions;

using static gg.parse.compiler.CompilerFunctions;

namespace gg.parse.tests.examples
{
    /// <summary>
    /// Test the various compiler rules and the compiler itself as well
    /// as the rule functions.
    /// </summary>
    [TestClass]
    public class RuleCompilerTests
    {
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a literal 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileLiteral()
        {
            var litId = 42;
            var compiler = new RuleCompiler<char>();
            var context = new CompileContext<char>()
                .WithText("rule='foo'")
                .WithFunction(litId, CompileLiteral)
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),
                    
                    //token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(1, new(5, 5))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            context.AstNodes = [ 
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the literal
                    new(litId, new Range(1, 1))
                ])
            ];

            // compile a rule table which can tokenize 'foo'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var literalFunction = table.FindRule("rule");

            Assert.IsNotNull(literalFunction);

            // the compiled table's root should be able to parse a foo string 
            var validInput = "foo";
            var result = table.Root.Parse(validInput.ToCharArray(), 0);

            // the result should hold a token which describes a literal spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == literalFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == validInput.Length);

            var invalidInput = new string[] { "bar", "Foo", "f", "fo", "" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                Assert.IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a character set 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCharacterSet()
        {
            var setId = 42;
            var compiler = new RuleCompiler<char>();
            var context = new CompileContext<char>()
                .WithText("rule='abc'")
                .WithFunction(setId, CompileCharacterSet)
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    //token which captures the set value in the text from 5-10 ('foo')
                    new Annotation(1, new(5, 5))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            context.AstNodes = [
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the literal
                    new(setId, new Range(1, 1))
                ])
            ];

            // compile a rule table which can tokenize a character in the set of 'abc'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the set rule as 'rule'
            var setFunction = table.FindRule("rule");

            Assert.IsNotNull(setFunction);

            // the compiled table's root should be able to parse a foo string 
            var validInput = new string[] { "a", "b", "c" };
            for (var i = 0; i < validInput.Length; i++)
            {
                var result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a character in the set abc spanning
                // the length of the test text
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == setFunction.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                Assert.IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }

            // should not match any of these
            var invalidInput = new string[] { "A", "1", "_" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                var result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                Assert.IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a character range 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCharacterRange()
        {
            var rangeId = 42;
            var compiler = new RuleCompiler<char>();
            var context = new CompileContext<char>()
                .WithText("rule='a'..'e'")
                .WithFunction(rangeId, CompileCharacterRange)
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    //token which captures the range value in the text from 5-8 ('a')
                    new Annotation(1, new(5, 3)),

                    //token which captures the range value in the text from 10-13 ('e')
                    new Annotation(1, new(10, 3))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and range)
            context.AstNodes = [
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the literal
                    new(rangeId, new Range(1, 2), [
                        // min
                        new(rangeId, new Range(1, 1)),
                        // max
                        new(rangeId, new Range(2, 1)),
                    ])
                ])
            ];

            // compile a rule table which can tokenize a character in the set of 'abc'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the range rule as 'rule'
            var rangeRule = table.FindRule("rule");

            Assert.IsNotNull(rangeRule);

            // the compiled table's root should be able to parse any char in the range a..e 
            var validInput = new string[] { "a", "b", "c", "d", "e" };
            for (var i = 0; i < validInput.Length; i++)
            {
                var result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a character in the set abc spanning
                // the length of the test text
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == rangeRule.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                Assert.IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }

            // should not match any of these
            var invalidInput = new string[] { "A", "f", "1", "" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                var result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                Assert.IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an identifier
        /// </summary>
        [TestMethod]
        public void TestCompileIdentifier()
        {
            var indentifierId = 42;
            var compiler = new RuleCompiler<char>();
            var context = new CompileContext<char>()
                .WithText("rule=foo")
                .WithFunction(indentifierId, CompileIdentifier)
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    //token which captures the identifier value in the text from 5-10 ('foo')
                    new Annotation(1, new(5, 3))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            context.AstNodes = [
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the literal
                    new(indentifierId, new Range(1, 1))
                ])
            ];

            // insert a foo rule for reference to which the compiled rule refers
            // this foo parses a literal bar
            context.Output.RegisterRule(new MatchDataSequence<char>("foo", [.. "bar"]));

            // compile a rule table which can tokenize foo
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var identifierRule = table.FindRule("rule");

            Assert.IsNotNull(identifierRule);

            // the compiled table's root should be able to parse a bar string 
            var testText = "bar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes an identifier spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == identifierRule.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a group 
        /// consisting of a sequence of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileGroup()
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var sequenceId = 64;
            var groupId = 128;

            var context = new CompileContext<char>()
                .WithText("rule=('foo','bar')")
                .WithFunction(literalId, CompileLiteral)
                .WithFunction(sequenceId, CompileSequence)
                .WithFunction(groupId, CompileGroup)
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(1, new(6, 5)), // foo
                            new Annotation(1, new(12, 5))); // bar


            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // group
                    new (groupId, new Range(1, 2),[
                        // child capturing the sequence
                        new(sequenceId, new Range(1, 2), [
                            // foo literal
                            new(literalId, new Range(1, 1)),
                            // bar literal
                            new(literalId, new Range(2, 1))
                        ])
                    ])
                ])
            ];

            // compile a rule table which can tokenize 'foo'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var groupFunction = table.FindRule("rule");

            Assert.IsNotNull(groupFunction);

            // the compiled table's root should be able to parse a foobar string 
            var testText = "foobar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == groupFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a sequence
        /// of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileSequence()
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var sequenceId = 64;

            var context = new CompileContext<char>()
                .WithText("rule='foo','bar'")
                .WithFunction(literalId, CompileLiteral)
                .WithFunction(sequenceId, CompileSequence)
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(1, new(5, 5)), // foo
                            new Annotation(1, new(11, 5))); // bar


            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the sequence
                    new(sequenceId, new Range(1, 2), [
                        // foo literal
                        new(literalId, new Range(1, 1)),
                        // bar literal
                        new(literalId, new Range(2, 1))
                    ])
                ])
            ];

            // compile a rule table which can tokenize 'foo'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var sequenceFunction = table.FindRule("rule");

            Assert.IsNotNull(sequenceFunction);

            // the compiled table's root should be able to parse a foobar string 
            var testText = "foobar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == sequenceFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an option
        /// of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileOption()
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var optionId = 64;

            var context = new CompileContext<char>()
                .WithText("rule='foo'|'bar'")
                .WithFunction(literalId, CompileLiteral)
                .WithFunction(optionId, CompileOption)
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(1, new(5, 5)), // foo
                            new Annotation(1, new(11, 5))); // bar


            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the sequence
                    new(optionId, new Range(1, 2), [
                        // foo literal
                        new(literalId, new Range(1, 1)),
                        // bar literal
                        new(literalId, new Range(2, 1))
                    ])
                ])
            ];

            // compile a rule table which can tokenize 'foo'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var optionFunction = table.FindRule("rule");

            Assert.IsNotNull(optionFunction);

            // the compiled table's root should be able to parse a foo OR bar string 
            var testText = "foo";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == optionFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);

            // do the same test with bar
            testText = "bar";
            result = table.Root.Parse(testText.ToCharArray(), 0);
            
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == optionFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a match count or its variants (*, +, ?)
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCountFunction()
        {
            TestRegisterAndCompileCountFunction(CompileZeroOrMore, '*', 0, 0);
            TestRegisterAndCompileCountFunction(CompileOneOrMore, '+', 1, 0);
            TestRegisterAndCompileCountFunction(CompileZeroOrOne, '?', 0, 1);
        }

        private void TestRegisterAndCompileCountFunction(CompileFunction<char> function, char operatorChar, int min, int max)
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var countId = 64;

            var context = new CompileContext<char>()
                .WithText($"rule={operatorChar}'foo'")
                .WithFunction(literalId, CompileLiteral)
                .WithFunction(countId, function)
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(2, new(4, 1)), // operatorChar
                            new Annotation(3, new(6, 5))); // foo

            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // count function
                    new (countId, new Range(1, 2),[
                        // foo literal
                        new(literalId, new Range(2, 1))
                    ])
                ])
            ];

            // compile a rule table which can tokenize min-max x 'foo'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var countFunction = table.FindRule("rule");
            Assert.IsNotNull(countFunction);

            var testText = "";
            var result = ParseResult.Failure;

            
            // zero input should yield a match, with 0 range
            result = table.Root.Parse(testText.ToCharArray(), 0);
            if (min == 0)
            {
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.MatchedLength == 0);
            }
            else
            {
                Assert.IsFalse(result.FoundMatch);
            }

            for (var i = 0; i < min + 1; i++)
            {
                testText += "foo";
            }

            result = table.Root.Parse(testText.ToCharArray(), 0);
            
            Assert.IsTrue(result.FoundMatch);
            var expectedLength = max == 0 ? testText.Length : max * 3;
            Assert.IsTrue(result.MatchedLength == expectedLength);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == countFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);

            if (max > 0)
            {
                testText = "";

                for (var i = 0; i < max + 1; i++)
                {
                    testText += "foo";
                }
                
                result = table.Root.Parse(testText.ToCharArray(), 0);

                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.MatchedLength == testText.Length - 3);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == countFunction.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                Assert.IsTrue(result.Annotations[0].Length == max * 3);
            }
        }
    }
}
