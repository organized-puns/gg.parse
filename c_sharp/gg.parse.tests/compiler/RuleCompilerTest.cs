using gg.parse.compiler;

using static Microsoft.VisualStudio.TestTools.UnitTesting.Assert;
using static gg.parse.compiler.CompilerFunctions;

namespace gg.parse.tests.compiler
{
    [TestClass]
    public class RuleCompilerTest
    {
        [TestMethod]
        [ExpectedException(typeof(InvalidOperationException))]
        public void CreateRuleWithTheSameName_Compile_ExpectException()
        {
            var litId = 42;
            var compiler = new RuleCompiler<char>()
                    .RegisterFunction(litId, CompileLiteral);

            var session = new CompileSession<char>()
                .WithText("rule='foo';rule='bar';")
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    // token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(2, new(5, 5)),

                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(11, 4)),

                    // token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(2, new(16, 5))

                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            session.AstNodes = [
                new Annotation(0, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(1, new Range(0, 1)), 

                    // child capturing the token(s) defining the literal
                    new(litId, new Range(1, 1))
                ]),

                new Annotation(2, new(2, 2), [
                    // child capturing the token(s) defining the rule name
                    new(1, new Range(2, 1)), 

                    // child capturing the token(s) defining the literal
                    new(litId, new Range(3, 1))
                ])
            ];

            // should throw an exception because of two rules with the same name
            compiler.Compile(session);
        }


        [TestMethod]
        public void CreateRuleWithCustomPrecedence_Compile_ExpectRuleToHaveSamePrecedence()
        {
            var litId = 42;
            var rulePrecedence = 142;
            var compiler = new RuleCompiler<char>()
                    .RegisterFunction(litId, CompileLiteral);

            var session = new CompileSession<char>()
                .WithText($"rule {rulePrecedence} = 'foo';")
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    // token which captures the precedence value in the text from 5-8 (142)
                    new Annotation(1, new(5, 3)),

                    // token which captures the assignment operator in the text from 9-10 (=)
                    new Annotation(2, new(9, 1)),

                    // token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(3, new(11, 5))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            session.AstNodes = [
                new Annotation(0, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(1, new Range(0, 1)), 

                    // child capturing the token(s) defining the rule's precedence
                    new(2, new Range(1, 1)), 

                    // child capturing the token(s) defining the literal
                    new(litId, new Range(3, 1))
                ])
            ];

            // should result in no problems
            var table = compiler.Compile(session);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var literalFunction = table.FindRule("rule");

            IsNotNull(literalFunction);
            IsTrue(literalFunction.Precedence == rulePrecedence);
        }
    }
}
