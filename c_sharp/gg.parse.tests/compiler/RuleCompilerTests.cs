using gg.parse.compiler;
using gg.parse.rulefunctions;

using static gg.parse.compiler.CompilerFunctions;

namespace gg.parse.tests.compiler
{
    /// <summary>
    /// Test the various compiler rules and the compiler itself as well
    /// as the rule functions.
    /// </summary>
    [TestClass]
    public class RuleCompilerTests
    {
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a literal 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileLiteral()
        {
            var litId = 42;
            var compiler = new RuleCompiler<char>()
                    .RegisterFunction(litId, CompileLiteral);

            var context = new CompileSession<char>()
                .WithText("rule='foo'")
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),
                    
                    //token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(1, new(5, 5))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            context.AstNodes = [ 
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the literal
                    new(litId, new Range(1, 1))
                ])
            ];

            // compile a rule table which can tokenize 'foo'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var literalFunction = table.FindRule("rule");

            Assert.IsNotNull(literalFunction);

            // the compiled table's root should be able to parse a foo string 
            var validInput = "foo";
            var result = table.Root.Parse(validInput.ToCharArray(), 0);

            // the result should hold a token which describes a literal spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == literalFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == validInput.Length);

            var invalidInput = new string[] { "bar", "Foo", "f", "fo", "" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                Assert.IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a character set 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCharacterSet()
        {
            var setId = 42;
            var compiler = new RuleCompiler<char>()
                .RegisterFunction(setId, CompileCharacterSet);

            var context = new CompileSession<char>()
                .WithText("rule={'abc'}")    
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    //token which captures the set value in the text from 5-10 ('foo')
                    new Annotation(1, new(6, 5))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            context.AstNodes = [
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the sequence of set {'abc'}
                    new(setId, new Range(1, 1), [
                        // token(s) defining the set literal 'abc'
                        new(1, new Range(1, 1))
                    ])
                ])
            ];

            // compile a rule table which can tokenize a character in the set of 'abc'
            var table = compiler.Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the set rule as 'rule'
            var setFunction = table.FindRule("rule");

            Assert.IsNotNull(setFunction);

            // the compiled table's root should be able to parse a foo string 
            var validInput = new string[] { "a", "b", "c" };
            for (var i = 0; i < validInput.Length; i++)
            {
                var result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a character in the set abc spanning
                // the length of the test text
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == setFunction.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                Assert.IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }

            // should not match any of these
            var invalidInput = new string[] { "A", "1", "_" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                var result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                Assert.IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a character range 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCharacterRange()
        {
            var rangeId = 42;
            var compiler = new RuleCompiler<char>()
                   .RegisterFunction(rangeId, CompileCharacterRange);

            var session = new CompileSession<char>()
                .WithText("rule='a'..'e'")                
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    //token which captures the range value in the text from 5-8 ('a')
                    new Annotation(1, new(5, 3)),

                    //token which captures the range value in the text from 10-13 ('e')
                    new Annotation(1, new(10, 3))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and range)
            session.AstNodes = [
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the literal
                    new(rangeId, new Range(1, 2), [
                        // min
                        new(rangeId, new Range(1, 1)),
                        // max
                        new(rangeId, new Range(2, 1)),
                    ])
                ])
            ];

            // compile a rule table which can tokenize a character in the set of 'abc'
            var table = compiler.Compile(session);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the range rule as 'rule'
            var rangeRule = table.FindRule("rule");

            Assert.IsNotNull(rangeRule);

            // the compiled table's root should be able to parse any char in the range a..e 
            var validInput = new string[] { "a", "b", "c", "d", "e" };
            for (var i = 0; i < validInput.Length; i++)
            {
                var result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a character in the set abc spanning
                // the length of the test text
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == rangeRule.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                Assert.IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }

            // should not match any of these
            var invalidInput = new string[] { "A", "f", "1", "" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                var result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                Assert.IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an identifier
        /// </summary>
        [TestMethod]
        public void TestCompileIdentifier()
        {
            var indentifierId = 42;
            var compiler = new RuleCompiler<char>()
                    .RegisterFunction(indentifierId, CompileIdentifier);

            var context = new CompileSession<char>()
                .WithText("rule=foo")
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    //token which captures the identifier value in the text from 5-10 ('foo')
                    new Annotation(1, new(5, 3))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            context.AstNodes = [
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the identifier 
                    new(indentifierId, new Range(1, 1), [
                        // no production annotation, therefore defaults to annotation
                        // identifier name
                        new (0, new Range(1,1))
                    ])
                ])
            ];

            var table = new RuleTable<char>();

            // insert a foo rule for reference to which the compiled rule refers
            // this foo parses a literal bar
            table.RegisterRule(new MatchDataSequence<char>("foo", [.. "bar"]));

            // compile a rule table which can tokenize foo
            table = compiler.Compile(context, table);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var identifierRule = table.FindRule("rule");

            Assert.IsNotNull(identifierRule);

            // the compiled table's root should be able to parse a bar string 
            var testText = "bar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes an identifier spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == identifierRule.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an identifier
        /// with an explicit product
        /// </summary>
        [TestMethod]
        public void TestCompileIdentifierWithProduct()
        {
            var indentifierId = 42;
            var noneProductId = 62;

            var compiler = new RuleCompiler<char>()
                .RegisterFunction(indentifierId, CompileIdentifier);
            var context = new CompileSession<char>()
                .WithText("rule=~foo")
                // tokens normally generated by a tokenizer
                .WithTokens(
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(0, new(0, 4)),

                    // token which captures the product which runs in the text from 5-1 (rule)
                    new Annotation(0, new(5, 1)),
                    
                    //token which captures the identifier value in the text from 6-9 ('foo')
                    new Annotation(1, new(6, 3))
                );

            // ast tree normally generated by a parser
            // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
            context.AstNodes = [
                new Annotation(2, new(0, 2), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the token(s) defining the literal
                    new(indentifierId, new Range(1, 2), [
                        // production
                        new (noneProductId, new Range(1,1)),
                        // name
                        new (2, new Range(2,1)),
                    ])
                ])
            ];

            context.ProductLookup = [(noneProductId, AnnotationProduct.None)];

            // compile a rule table which can tokenize foo
            var table = new RuleTable<char>();

            // insert a foo rule for reference to which the compiled rule refers
            // this foo parses a literal bar
            table.RegisterRule(new MatchDataSequence<char>("foo", [.. "bar"]));

            table = compiler.Compile(context, table);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var identifierRule = table.FindRule("rule");

            Assert.IsNotNull(identifierRule);
            Assert.IsTrue(identifierRule.Production == AnnotationProduct.None);

            // the compiled table's root should be able to parse a bar string 
            var testText = "bar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // 
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations == null);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a group 
        /// consisting of a sequence of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileGroup()
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var sequenceId = 64;
            var groupId = 128;

            var context = new CompileSession<char>()
                .WithText("rule=('foo','bar')")
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(1, new(6, 5)), // foo
                            new Annotation(1, new(12, 5))); // bar

            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // group
                    new (groupId, new Range(1, 2),[
                        // child capturing the sequence
                        new(sequenceId, new Range(1, 2), [
                            // foo literal
                            new(literalId, new Range(1, 1)),
                            // bar literal
                            new(literalId, new Range(2, 1))
                        ])
                    ])
                ])
            ];

            // compile a rule table which can tokenize 'foo'
            var table = compiler
                .RegisterFunction(literalId, CompileLiteral)
                .RegisterFunction(sequenceId, CompileSequence)
                .RegisterFunction(groupId, CompileGroup)
                .Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var groupFunction = table.FindRule("rule");

            Assert.IsNotNull(groupFunction);

            // the compiled table's root should be able to parse a foobar string 
            var testText = "foobar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == groupFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a sequence
        /// of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileSequence()
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var sequenceId = 64;

            var session = new CompileSession<char>()
                .WithText("rule='foo','bar'")
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(1, new(5, 5)), // foo
                            new Annotation(1, new(11, 5))); // bar


            session.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the sequence
                    new(sequenceId, new Range(1, 2), [
                        // foo literal
                        new(literalId, new Range(1, 1)),
                        // bar literal
                        new(literalId, new Range(2, 1))
                    ])
                ])
            ];

            // compile a rule table which can tokenize 'foo'
            var table = compiler
                    .RegisterFunction(literalId, CompileLiteral)
                    .RegisterFunction(sequenceId, CompileSequence)
                    .Compile(session);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var sequenceFunction = table.FindRule("rule");

            Assert.IsNotNull(sequenceFunction);

            // the compiled table's root should be able to parse a foobar string 
            var testText = "foobar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == sequenceFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an option
        /// of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileOption()
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var optionId = 64;

            var session = new CompileSession<char>()
                .WithText("rule='foo'|'bar'")
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(1, new(5, 5)), // foo
                            new Annotation(1, new(11, 5))); // bar


            session.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // child capturing the sequence
                    new(optionId, new Range(1, 2), [
                        // foo literal
                        new(literalId, new Range(1, 1)),
                        // bar literal
                        new(literalId, new Range(2, 1))
                    ])
                ])
            ];

            // compile a rule table which can tokenize 'foo'
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(optionId, CompileOption)
                        .Compile(session);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var optionFunction = table.FindRule("rule");

            Assert.IsNotNull(optionFunction);

            // the compiled table's root should be able to parse a foo OR bar string 
            var testText = "foo";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == optionFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);

            // do the same test with bar
            testText = "bar";
            result = table.Root.Parse(testText.ToCharArray(), 0);
            
            Assert.IsTrue(result.FoundMatch);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == optionFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a match count or its variants (*, +, ?)
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCountFunction()
        {
            TestRegisterAndCompileCountFunction(CompileZeroOrMore, '*', 0, 0);
            TestRegisterAndCompileCountFunction(CompileOneOrMore, '+', 1, 0);
            TestRegisterAndCompileCountFunction(CompileZeroOrOne, '?', 0, 1);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a not rule
        /// </summary>
        [TestMethod]
        public void TestNotFunction()
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var notId = 64;

            var context = new CompileSession<char>()
                .WithText($"rule=!'foo'")
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(2, new(4, 1)), // operatorChar
                            new Annotation(3, new(6, 5))); // foo

            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // not function
                    new (notId, new Range(1, 2),[
                        // foo literal
                        new(literalId, new Range(2, 1))
                    ])
                ])
            ];

            // compile a rule table which can tokenize not 'foo'
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(notId, CompileNot)
                        .Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var notFunction = table.FindRule("rule");
            Assert.IsNotNull(notFunction);

            var validInput = new string[] { "a", "", "_", "FoO", "fOo", "FOO", "fo" };
            var result = ParseResult.Failure;

            for (var i = 0; i < validInput.Length; i++)
            {
                result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a not foo
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == notFunction.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                Assert.IsTrue(result.Annotations[0].Length == 0);
            }

            var invalidInput = "foo";
            
            result = table.Root.Parse(invalidInput.ToCharArray(), 0);
            Assert.IsFalse(result.FoundMatch);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a any rule
        /// </summary>
        [TestMethod]
        public void TestAnyFunction()
        {
            var compiler = new RuleCompiler<char>();

            var anyId = 64;

            var context = new CompileSession<char>()
                .WithText($"rule=.")
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(1, new(4, 1))); // any

            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // any function
                    new (anyId, new Range(1, 1))
                ])
            ];

            // compile a rule table which can tokenize 'any' char
            var table = compiler
                        .RegisterFunction(anyId, CompileAny)
                        .Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var anyFunction = table.FindRule("rule");
            Assert.IsNotNull(anyFunction);

            var validInput = new string[] { "a", "b", "1", "_", "~" };
            var result = ParseResult.Failure;

            for (var i = 0; i < validInput.Length; i++)
            {
                result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a not foo
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == anyFunction.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                Assert.IsTrue(result.Annotations[0].Length == 1);
            }

            var invalidInput = "";

            result = table.Root.Parse(invalidInput.ToCharArray(), 0);
            Assert.IsFalse(result.FoundMatch);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// an error rule
        /// </summary>
        [TestMethod]
        public void TestErrorFunction()
        {
            var compiler = new RuleCompiler<char>();

            var litId = 42;
            var errorId = 64;

            var context = new CompileSession<char>()
                .WithText($"rule=error 'message' 'foo'")
                .WithTokens(new Annotation(0, new(0, 4)),  // rule
                            new Annotation(1, new(4, 5)),  // error declaration
                            new Annotation(1, new(10, 8)), // message
                            new Annotation(1, new(19, 5))  // match literal
                ); 

            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // error
                    new (errorId, new Range(1, 3), [
                        new (0, new Range(1, 1)),       // error decl
                        new (1, new Range(2, 1)),       // message
                        new (litId, new Range(3, 1)),   // skip function
                    ])
                ])
            ];

            // compile a rule table which can tokenize invoke an error
            var table = compiler
                        .RegisterFunction(litId, CompileLiteral)
                        .RegisterFunction(errorId, CompileError)
                        .Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the error as 'rule'
            var errorRule = table.FindRule("rule");
            Assert.IsNotNull(errorRule);

            var validInput = new string[] { "foo", "123foo", "123", "" };
            var result = ParseResult.Failure;

            for (var i = 0; i < validInput.Length; i++)
            {
                result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a not foo
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == errorRule.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                // error should have skipped until the end of the input (as all cases have 
                // foo at their end or no foo)
                Assert.IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }
        }

        private void TestRegisterAndCompileCountFunction(CompileFunction<char> function, char operatorChar, int min, int max)
        {
            var compiler = new RuleCompiler<char>();

            var literalId = 42;
            var countId = 64;

            var context = new CompileSession<char>()
                .WithText($"rule={operatorChar}'foo'")
                .WithTokens(new Annotation(0, new(0, 4)), // rule
                            new Annotation(2, new(4, 1)), // operatorChar
                            new Annotation(3, new(6, 5))); // foo

            context.AstNodes = [
                new Annotation(2, new(0, 3), [
                    // child capturing the token(s) defining the rule name
                    new(0, new Range(0, 1)), 

                    // count function
                    new (countId, new Range(1, 2),[
                        // foo literal
                        new(literalId, new Range(2, 1))
                    ])
                ])
            ];

            // compile a rule table which can tokenize min-max x 'foo'
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(countId, function)
                        .Compile(context);

            Assert.IsNotNull(table);
            Assert.IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var countFunction = table.FindRule("rule");
            Assert.IsNotNull(countFunction);

            var testText = "";
            var result = ParseResult.Failure;

            
            // zero input should yield a match, with 0 range
            result = table.Root.Parse(testText.ToCharArray(), 0);
            if (min == 0)
            {
                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.MatchedLength == 0);
            }
            else
            {
                Assert.IsFalse(result.FoundMatch);
            }

            for (var i = 0; i < min + 1; i++)
            {
                testText += "foo";
            }

            result = table.Root.Parse(testText.ToCharArray(), 0);
            
            Assert.IsTrue(result.FoundMatch);
            var expectedLength = max == 0 ? testText.Length : max * 3;
            Assert.IsTrue(result.MatchedLength == expectedLength);
            Assert.IsTrue(result.Annotations != null);
            Assert.IsTrue(result.Annotations.Count == 1);
            Assert.IsTrue(result.Annotations[0].FunctionId == countFunction.Id);
            Assert.IsTrue(result.Annotations[0].Start == 0);
            Assert.IsTrue(result.Annotations[0].Length == testText.Length);

            if (max > 0)
            {
                testText = "";

                for (var i = 0; i < max + 1; i++)
                {
                    testText += "foo";
                }
                
                result = table.Root.Parse(testText.ToCharArray(), 0);

                Assert.IsTrue(result.FoundMatch);
                Assert.IsTrue(result.MatchedLength == testText.Length - 3);
                Assert.IsTrue(result.Annotations != null);
                Assert.IsTrue(result.Annotations.Count == 1);
                Assert.IsTrue(result.Annotations[0].FunctionId == countFunction.Id);
                Assert.IsTrue(result.Annotations[0].Start == 0);
                Assert.IsTrue(result.Annotations[0].Length == max * 3);
            }
        }


    }
}
