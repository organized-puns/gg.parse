using gg.parse.script.compiler;
using gg.parse.util;
using System.Text;
using System.Text.RegularExpressions;

namespace gg.parse.script
{
    public static class ScriptUtils
    {
        public static string AstToString(ParserBuilder parser)
        {
            Assertions.RequiresNotNull(parser);
            Assertions.RequiresNotNull(parser!.GrammarSession!);
            Assertions.RequiresNotNull(parser.GrammarSession!.Text!);
            Assertions.RequiresNotNull(parser.GrammarSession!.Tokens!);
            Assertions.RequiresNotNull(parser.GrammarSession!.SyntaxTree!);

            return AstToString(parser.GrammarSession.Text!, parser.GrammarSession.Tokens!, parser.GrammarSession.SyntaxTree!);
        }

        public static string AstToString(string text, List<Annotation> tokens, List<Annotation> astNodes, string indentStr = "   ")
        {
            var builder = new StringBuilder();
            var indent = 0;

            if (tokens != null && astNodes.Count > 0)
            {
                foreach (var astNode in astNodes)
                {
                    builder.Append(AstToString(indent, indentStr, astNode, text, tokens));
                }
            }

            return builder.ToString();
        }

        private static string AstToString(int indentCount, string indentStr, Annotation node, string text, List<Annotation> tokens)
        {
            var builder = new StringBuilder();

            var rule = node.Rule;

            for (var i = 0; i < indentCount; i++)
            {
                builder.Append(indentStr);
            }

            var nodeText = Regex.Escape(node.GetText(text, tokens));

            if (nodeText.Length > 20)
            {
                nodeText = $"{nodeText.Substring(0, 17)}...";
            }

            builder.AppendLine($"[{node.Range.Start},{node.Range.End}]{rule.Name}({rule.Id}): {nodeText}");

            if (node.Children != null && node.Children.Count > 0)
            {
                foreach (var child in node.Children)
                {
                    builder.Append(AstToString(indentCount + 1, indentStr, child, text, tokens));
                }
            }

            return builder.ToString();
        }

        public static string ExportNames<TTokens, TGrammar>(
            RuleGraph<TTokens>? tokenGraph, 
            RuleGraph<TGrammar>? grammarGraph, 
            string usingNameSpace,
            string className) 
            where TTokens : IComparable<TTokens>
            where TGrammar : IComparable<TGrammar>
        {
            var builder = new StringBuilder();
            var ruleSet = new HashSet<string>();

            builder.AppendLine($"// Autogenerated class using gg.parse.script.ScriptUtils.ExportNames.");
            builder.AppendLine($"// Strongly recommend to refrain from making changes in this class as they made be overwritten.");
            builder.AppendLine($"namespace {usingNameSpace}");
            builder.AppendLine($"{{");
            builder.AppendLine($"   public static class {className}");
            builder.AppendLine($"   {{");

            if (tokenGraph != null)
            {
                AppendRules(tokenGraph, ruleSet, builder);
            }

            if (grammarGraph != null)
            {
                AppendRules(grammarGraph, ruleSet, builder);
            }

            builder.AppendLine($"   }}");
            builder.AppendLine($"}}");

            return builder.ToString();

            void AppendRules<T>(RuleGraph<T> graph, HashSet<string> ruleSet, StringBuilder builder) where T : IComparable<T>
            {
                foreach (var rule in graph)
                {
                    if (!string.IsNullOrEmpty(rule.Name) && !rule.Name.StartsWith(CompilerFunctions.UnnamedRulePrefix))
                    {
                        var ruleName = rule.Name.RemoveUnderscoresAndCapitalize();

                        if (!ruleSet.Contains(ruleName))
                        {
                            builder.AppendLine($"        public static readonly string {ruleName} = \"{rule.Name}\";");
                            ruleSet.Add(ruleName);
                        }
                    }
                }
            }
        }

        public static string RemoveUnderscoresAndCapitalize(this string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            var result = new StringBuilder();

            // capitalize first 
            bool capitalizeNext = true;

            foreach (char c in input)
            {
                if (c == '_')
                {
                    capitalizeNext = true;
                }
                else
                {
                    result.Append(capitalizeNext ? char.ToUpper(c) : c);
                    capitalizeNext = false;
                }
            }

            return result.ToString();
        }
    }
}
