// SPDX-License-Identifier: MIT
// Copyright (c) Pointless pun
using System.Collections.Immutable;
using System.Text;
using System.Text.RegularExpressions;
using gg.parse.core;
using gg.parse.script.compiler;

namespace gg.parse.script
{
    public static class ScriptUtils
    {
        public static string PrettyPrintTokens(string text, ImmutableList<Annotation> tokens, string indentStr = "   ")
        {
            var builder = new StringBuilder();
            var indent = 0;

            if (tokens != null && tokens.Count > 0)
            {
                foreach (var tokenNode in tokens)
                {
                    builder.Append(PrettyPrintToken(indent, indentStr, tokenNode, text));
                }
            }

            return builder.ToString();
        }

        private static string PrettyPrintToken(int indentCount, string indentStr, Annotation token, string text)
        {
            var builder = new StringBuilder();

            var rule = token.Rule;

            for (var i = 0; i < indentCount; i++)
            {
                builder.Append(indentStr);
            }

            var nodeText = Regex.Escape(token.GetText(text));

            if (nodeText.Length > 20)
            {
                nodeText = $"{nodeText[..17]}...";
            }

            builder.AppendLine($"[{token.Range.Start},{token.Range.End}]{rule.Name}({rule.Id}): {nodeText}");

            if (token.Children != null && token.Children.Count > 0)
            {
                foreach (var child in token.Children)
                {
                    builder.Append(PrettyPrintToken(indentCount + 1, indentStr, child, text));
                }
            }

            return builder.ToString();
        }

        public static string PrettyPrintSyntaxTree(string text, ImmutableList<Annotation> tokens, ImmutableList<Annotation> astNodes, string indentStr = "   ")
        {
            var builder = new StringBuilder();
            var indent = 0;

            if (tokens != null && astNodes.Count > 0)
            {
                foreach (var astNode in astNodes)
                {
                    builder.Append(PrettyPrintSyntaxTree(indent, indentStr, astNode, text, tokens));
                }
            }

            return builder.ToString();
        }

        private static string PrettyPrintSyntaxTree(int indentCount, string indentStr, Annotation node, string text, ImmutableList<Annotation> tokens)
        {
            var builder = new StringBuilder();

            var rule = node.Rule;

            for (var i = 0; i < indentCount; i++)
            {
                builder.Append(indentStr);
            }

            var nodeText = Regex.Escape(node.GetText(text, tokens));

            if (nodeText.Length > 20)
            {
                nodeText = $"{nodeText[..17]}...";
            }

            builder.AppendLine($"[{node.Range.Start},{node.Range.End}]{rule.Name}({rule.Id}): {nodeText}");

            if (node.Children != null && node.Children.Count > 0)
            {
                foreach (var child in node.Children)
                {
                    builder.Append(PrettyPrintSyntaxTree(indentCount + 1, indentStr, child, text, tokens));
                }
            }

            return builder.ToString();
        }

        public static string ExportNames<TTokens, TGrammar>(
            RuleGraph<TTokens>? tokenGraph, 
            RuleGraph<TGrammar>? grammarGraph, 
            string usingNameSpace,
            string className) 
            where TTokens : IComparable<TTokens>
            where TGrammar : IComparable<TGrammar>
        {
            var builder = new StringBuilder();
            var ruleSet = new HashSet<string>();

            builder.AppendLine($"// Autogenerated class using gg.parse.script.ScriptUtils.ExportNames.");
            builder.AppendLine($"// Strongly recommend to refrain from making changes in this class as they made be overwritten.");
            builder.AppendLine($"namespace {usingNameSpace}");
            builder.AppendLine($"{{");
            builder.AppendLine($"   public static class {className}");
            builder.AppendLine($"   {{");

            if (tokenGraph != null)
            {
                AppendRules(tokenGraph, ruleSet, builder);
            }

            if (grammarGraph != null)
            {
                AppendRules(grammarGraph, ruleSet, builder);
            }

            builder.AppendLine($"   }}");
            builder.AppendLine($"}}");

            return builder.ToString();

            static void AppendRules<T>(RuleGraph<T> graph, HashSet<string> ruleSet, StringBuilder builder) where T : IComparable<T>
            {
                foreach (var rule in graph)
                {
                    if (!string.IsNullOrEmpty(rule.Name) 
                        && !rule.Name.StartsWith(CompilerFunctionNameGenerator.UnnamedRulePrefix))
                    {
                        var ruleName = rule.Name.RemoveUnderscoresAndCapitalize();

                        if (!ruleSet.Contains(ruleName))
                        {
                            builder.AppendLine($"        public const string {ruleName} = \"{rule.Name}\";");
                            ruleSet.Add(ruleName);
                        }
                    }
                }
            }
        }

        public static string RemoveUnderscoresAndCapitalize(this string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            var result = new StringBuilder();
            bool capitalizeNext = true;

            foreach (char c in input)
            {
                if (c == '_')
                {
                    capitalizeNext = true;
                }
                else
                {
                    result.Append(capitalizeNext ? char.ToUpper(c) : c);
                    capitalizeNext = false;
                }
            }

            return result.ToString();
        }
    }
}
