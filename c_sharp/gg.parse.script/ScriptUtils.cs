// SPDX-License-Identifier: MIT
// Copyright (c) Pointless pun

using System.Collections.Immutable;
using System.Data;
using System.Text;

using gg.parse.core;
using gg.parse.rules;
using gg.parse.script.compiler;
using gg.parse.util;

namespace gg.parse.script
{
    public static class ScriptUtils
    {
        public static string PrettyPrintTokens(string text, ImmutableList<Annotation> tokens, string indentStr = "   ")
        {
            var builder = new StringBuilder();
            var indent = 0;

            if (tokens != null && tokens.Count > 0)
            {
                foreach (var tokenNode in tokens)
                {
                    builder.Append(PrettyPrintToken(indent, indentStr, tokenNode, text));
                }
            }

            return builder.ToString();
        }

        private static string PrettyPrintToken(int indentCount, string indentStr, Annotation token, string text)
        {
            var builder = new StringBuilder();

            var rule = token.Rule;

            for (var i = 0; i < indentCount; i++)
            {
                builder.Append(indentStr);
            }

            var nodeText = token.GetText(text).SimpleEscape();

            if (nodeText.Length > 20)
            {
                nodeText = $"{nodeText[..17]}...";
            }

            builder.AppendLine($"[{token.Range.Start},{token.Range.End}]{rule.Name}({rule.Id}): {nodeText}");

            if (token.Children != null && token.Children.Count > 0)
            {
                foreach (var child in token.Children)
                {
                    builder.Append(PrettyPrintToken(indentCount + 1, indentStr, child, text));
                }
            }

            return builder.ToString();
        }

        public static string PrettyPrintSyntaxTree(string text, ImmutableList<Annotation> tokens, ImmutableList<Annotation> astNodes, string indentStr = "   ")
        {
            var builder = new StringBuilder();
            var indent = 0;

            if (tokens != null && astNodes.Count > 0)
            {
                foreach (var astNode in astNodes)
                {
                    builder.Append(PrettyPrintSyntaxTree(indent, indentStr, astNode, text, tokens));
                }
            }

            return builder.ToString();
        }

        private static string PrettyPrintSyntaxTree(int indentCount, string indentStr, Annotation node, string text, ImmutableList<Annotation> tokens)
        {
            var builder = new StringBuilder();

            var rule = node.Rule;

            for (var i = 0; i < indentCount; i++)
            {
                builder.Append(indentStr);
            }

            var nodeText = node.GetText(text, tokens).SimpleEscape();

            if (nodeText.Length > 20)
            {
                nodeText = $"{nodeText[..17]}...";
            }

            builder.AppendLine($"[{node.Range.Start},{node.Range.End}]{rule.Name}({rule.Id}): {nodeText}");

            if (node.Children != null && node.Children.Count > 0)
            {
                foreach (var child in node.Children)
                {
                    builder.Append(PrettyPrintSyntaxTree(indentCount + 1, indentStr, child, text, tokens));
                }
            }

            return builder.ToString();
        }

        public static string ExportNames<TTokens, TGrammar>(
            RuleGraph<TTokens>? tokenGraph, 
            RuleGraph<TGrammar>? grammarGraph, 
            string usingNameSpace,
            string className) 
            where TTokens : IComparable<TTokens>
            where TGrammar : IComparable<TGrammar>
        {
            var builder = new StringBuilder();
            var ruleSet = new Dictionary<string, string>();

            builder.AppendLine($"// Autogenerated class using gg.parse.script.ScriptUtils.ExportNames.");
            builder.AppendLine($"// Strongly recommend to refrain from making changes in this class as they made be overwritten.");
            builder.AppendLine($"namespace {usingNameSpace}");
            builder.AppendLine($"{{");
            builder.AppendLine($"   public static class {className}");
            builder.AppendLine($"   {{");

            if (tokenGraph != null)
            {
                CollectRules(tokenGraph, ruleSet);
            }

            if (grammarGraph != null)
            {
                CollectRules(grammarGraph, ruleSet);
            }

            ruleSet
                .ToList().OrderBy( entry => entry.Key)
                .ForEach( entry =>
                    builder.AppendLine($"        public const string {entry.Key} = \"{entry.Value}\";"));
 
            builder.AppendLine($"   }}");
            builder.AppendLine($"}}");

            return builder.ToString();

            static void CollectRules<T>(RuleGraph<T> graph, Dictionary<string, string> ruleSet) where T : IComparable<T>
            {
                graph.Where(rule => !string.IsNullOrEmpty(rule.Name)
                        && !rule.Name.StartsWith(CompilerFunctionNameGenerator.UnnamedRulePrefix))
                    .ForEach(rule => ruleSet[rule.Name.RemoveUnderscoresAndCapitalize()] = rule.Name);
            }          
        }

        public static string ExportTokens<TTokens>(
            RuleGraph<TTokens>? tokenGraph,
            string usingNameSpace,
            string className)
            where TTokens : IComparable<TTokens>
        {
            var builder = new StringBuilder();
            var ruleSet = new Dictionary<string, string>();

            builder.AppendLine($"// Autogenerated class using gg.parse.script.ScriptUtils.ExportTokens.");
            builder.AppendLine($"// Strongly recommend to refrain from making changes in this class as they made be overwritten.");
            builder.AppendLine($"namespace {usingNameSpace}");
            builder.AppendLine($"{{");
            builder.AppendLine($"   public static class {className}");
            builder.AppendLine($"   {{");

            tokenGraph?.Where(rule => !string.IsNullOrEmpty(rule.Name)
                        && rule is MatchDataSequence<TTokens>
                        && !rule.Name.StartsWith(CompilerFunctionNameGenerator.UnnamedRulePrefix))

                    .Cast<MatchDataSequence<TTokens>>()

                    .ForEach(rule => ruleSet[rule.Name.RemoveUnderscoresAndCapitalize()] = string.Join("", rule.DataArray));

            ruleSet
                .ToList().OrderBy(entry => entry.Key)
                .ForEach(entry =>
                    builder.AppendLine($"        public const string {entry.Key} = \"{entry.Value}\";"));

            builder.AppendLine($"   }}");
            builder.AppendLine($"}}");

            return builder.ToString();
        }

        public static string RemoveUnderscoresAndCapitalize(this string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            var result = new StringBuilder();
            bool capitalizeNext = true;

            foreach (char c in input)
            {
                if (c == '_')
                {
                    capitalizeNext = true;
                }
                else
                {
                    result.Append(capitalizeNext ? char.ToUpper(c) : c);
                    capitalizeNext = false;
                }
            }

            return result.ToString();
        }
    }
}
