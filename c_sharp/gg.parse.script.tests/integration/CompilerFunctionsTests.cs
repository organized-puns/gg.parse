#nullable disable

using gg.parse.rules;

using gg.parse.script.compiler;

using gg.parse.tests;

using static Microsoft.VisualStudio.TestTools.UnitTesting.Assert;

using static gg.parse.script.compiler.CompilerFunctions;


namespace gg.parse.script.tests.integration
{
    /// <summary>
    /// Test the various compiler functions.
    /// </summary>
    [TestClass]
    public class CompilerFunctionsTests
    {
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a literal 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileLiteral()
        {
            var litId = 42;
            var compiler = new RuleCompiler()
                    .RegisterFunction(litId, CompileLiteral);

            var session = new CompileSession(
                compiler,
                text: "rule='foo'",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),
                    
                    //token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(new EmptyRule(1), new(5, 5))
                ],
                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the literal
                        new(new EmptyRule(litId), new Range(1, 1))
                    ])
                ]
            );

            // compile a rule table which can tokenize 'foo'
            var table = compiler.Compile<char>(session);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var literalFunction = table.FindRule("rule");

            IsNotNull(literalFunction);

            // the compiled table's root should be able to parse a foo string 
            var validInput = "foo";
            var result = table.Root.Parse(validInput.ToCharArray(), 0);

            // the result should hold a token which describes a literal spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == literalFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == validInput.Length);

            var invalidInput = new string[] { "bar", "Foo", "f", "fo", "" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a character set 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCharacterSet()
        {
            var setId = 42;
            var compiler = new RuleCompiler()
                .RegisterFunction(setId, CompileCharacterSet);

            var session = new CompileSession(
                compiler,
                text: "rule={'abc'}",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    //token which captures the set value in the text from 5-10 ('foo')
                    new Annotation(new EmptyRule(1), new(6, 5))
                ],
                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the sequence of set {'abc'}
                        new(new EmptyRule(setId), new Range(1, 1), [
                            // token(s) defining the set literal 'abc'
                            new(new EmptyRule(1), new Range(1, 1))
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize a character in the set of 'abc'
            var table = compiler.Compile<char>(session);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the set rule as 'rule'
            var setFunction = table.FindRule("rule");

            IsNotNull(setFunction);

            // the compiled table's root should be able to parse a foo string 
            var validInput = new string[] { "a", "b", "c" };
            for (var i = 0; i < validInput.Length; i++)
            {
                var result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a character in the set abc spanning
                // the length of the test text
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == setFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }

            // should not match any of these
            var invalidInput = new string[] { "A", "1", "_" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                var result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a character range 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCharacterRange()
        {
            var rangeId = 42;
            var compiler = new RuleCompiler()
                   .RegisterFunction(rangeId, CompileCharacterRange);

            var session = new CompileSession(
                compiler,
                text: "rule='a'..'e'",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    //token which captures the range value in the text from 5-8 ('a')
                    new Annotation(new EmptyRule(1), new(5, 3)),

                    //token which captures the range value in the text from 10-13 ('e')
                    new Annotation(new EmptyRule(1), new(10, 3))
                ],

                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and range)
                 syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the literal
                        new(new EmptyRule(rangeId), new Range(1, 2), [
                            // min
                            new(new EmptyRule(rangeId), new Range(1, 1)),
                            // max
                            new(new EmptyRule(rangeId), new Range(2, 1)),
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize a character in the set of 'abc'
            var table = compiler.Compile<char>(session);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the range rule as 'rule'
            var rangeRule = table.FindRule("rule");

            IsNotNull(rangeRule);

            // the compiled table's root should be able to parse any char in the range a..e 
            var validInput = new string[] { "a", "b", "c", "d", "e" };
            for (var i = 0; i < validInput.Length; i++)
            {
                var result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a character in the set abc spanning
                // the length of the test text
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == rangeRule);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }

            // should not match any of these
            var invalidInput = new string[] { "A", "f", "1", "" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                var result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                IsFalse(result.FoundMatch);
            }
        }
        
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an identifier
        /// </summary>
        [TestMethod]
        public void TestCompileIdentifier()
        {
            var indentifierId = 42;
            var compiler = new RuleCompiler()
                    .RegisterFunction(indentifierId, CompileIdentifier<char>);

            var context = new CompileSession(
                compiler,
                text: "rule=foo",

                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    //token which captures the identifier value in the text from 5-10 ('foo')
                    new Annotation(new EmptyRule(1), new(5, 3))
                ],

                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the identifier 
                        new(new EmptyRule(indentifierId), new Range(1, 1), [
                            // no production annotation, therefore defaults to annotation
                            // identifier name
                            new (new EmptyRule(0), new Range(1,1))
                        ])
                    ])
                ]
            );

            var table = new RuleGraph<char>();

            // insert a foo rule for reference to which the compiled rule refers
            // this foo parses a literal bar
            table.RegisterRule(new MatchDataSequence<char>("foo", [.. "bar"]));

            // compile a rule table which can tokenize foo
            table = compiler.Compile(context, table);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var identifierRule = table.FindRule("rule");

            IsNotNull(identifierRule);

            // the compiled table's root should be able to parse a bar string 
            var testText = "bar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes an identifier spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == identifierRule);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);
        }
        
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an identifier
        /// with an explicit product
        /// </summary>
        [TestMethod]
        public void TestCompileIdentifierWithProduct()
        {
            var indentifierId = 42;
            var noneProductId = 62;

            var compiler = new RuleCompiler()
                .RegisterFunction(indentifierId, CompileIdentifier<char>);
            var context = new CompileSession(
                compiler,
                text: "rule=~foo",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    // token which captures the product which runs in the text from 5-1 (rule)
                    new Annotation(new EmptyRule(0), new(5, 1)),
                    
                    //token which captures the identifier value in the text from 6-9 ('foo')
                    new Annotation(new EmptyRule(1), new(6, 3))
                ],

                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree:  [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the literal
                        new(new EmptyRule(indentifierId), new Range(1, 2), [
                            // production
                            new (new EmptyRule(noneProductId), new Range(1,1)),
                            // name
                            new (new EmptyRule(2), new Range(2,1)),
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize foo
            var table = new RuleGraph<char>();

            // insert a foo rule for reference to which the compiled rule refers
            // this foo parses a literal bar
            table.RegisterRule(new MatchDataSequence<char>("foo", [.. "bar"]));

            table = compiler
                    .WithAnnotationProductMapping([(noneProductId, IRule.Output.Void)])
                    .Compile(context, table);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var identifierRule = table.FindRule("rule");

            IsNotNull(identifierRule);
            IsTrue(identifierRule.Production == IRule.Output.Void);

            // the compiled table's root should be able to parse a bar string 
            var testText = "bar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // 
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations == null);
        }

        
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a group 
        /// consisting of a sequence of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileGroup()
        {
            var compiler = new RuleCompiler();

            var literalId = 42;
            var sequenceId = 64;
            var groupId = 128;

            var context = new CompileSession(
                compiler,
                text: "rule=('foo','bar')",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(6, 5)), // foo
                            new Annotation(new EmptyRule(1), new(12, 5))], // bar

                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // group
                        new (new EmptyRule(groupId), new Range(1, 2),[
                            // child capturing the sequence
                            new(new EmptyRule(sequenceId), new Range(1, 2), [
                                // foo literal
                                new(new EmptyRule(literalId), new Range(1, 1)),
                                // bar literal
                                new(new EmptyRule(literalId), new Range(2, 1))
                            ])
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize 'foo'
            var table = compiler
                .RegisterFunction(literalId, CompileLiteral)
                .RegisterFunction(sequenceId, CompileSequence<char>)
                .RegisterFunction(groupId, CompileGroup<char>)
                .Compile<char>(context);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var groupFunction = table.FindRule("rule");

            IsNotNull(groupFunction);

            // the compiled table's root should be able to parse a foobar string 
            var testText = "foobar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == groupFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a sequence
        /// of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileSequence()
        {
            var compiler = new RuleCompiler();

            var literalId = 42;
            var sequenceId = 64;

            var session = new CompileSession(
                compiler,
                text: "rule='foo','bar'",
                tokens : [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(5, 5)), // foo
                            new Annotation(new EmptyRule(1), new(11, 5))], // bar
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the sequence
                        new(new EmptyRule(sequenceId), new Range(1, 2), [
                            // foo literal
                            new(new EmptyRule(literalId), new Range(1, 1)),
                            // bar literal
                            new(new EmptyRule(literalId), new Range(2, 1))
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize 'foo'
            var table = compiler
                    .RegisterFunction(literalId, CompileLiteral)
                    .RegisterFunction(sequenceId, CompileSequence<char>)
                    .Compile<char>(session);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var sequenceFunction = table.FindRule("rule");

            IsNotNull(sequenceFunction);

            // the compiled table's root should be able to parse a foobar string 
            var testText = "foobar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == sequenceFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an option
        /// of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileOption()
        {
            var compiler = new RuleCompiler();

            var literalId = 42;
            var optionId = 64;

            var session = new CompileSession(
                compiler,
                text: "rule='foo'|'bar'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(5, 5)), // foo
                            new Annotation(new EmptyRule(1), new(11, 5))], // bar
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the sequence
                        new(new EmptyRule(optionId), new Range(1, 2), [
                            // foo literal
                            new(new EmptyRule(literalId), new Range(1, 1)),
                            // bar literal
                            new(new EmptyRule(literalId), new Range(2, 1))
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize 'foo'
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(optionId, CompileOption<char>)
                        .Compile<char>(session);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var optionFunction = table.FindRule("rule");

            IsNotNull(optionFunction);

            // the compiled table's root should be able to parse a foo OR bar string 
            var testText = "foo";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == optionFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);

            // do the same test with bar
            testText = "bar";
            result = table.Root.Parse(testText.ToCharArray(), 0);
            
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == optionFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an evaluation
        /// of literals (which is non-sensical but serves the purpose of the test)
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileSingleUnaryEvaluation()
        {
            var compiler = new RuleCompiler();

            var literalId = 42;
            var evalId = 64;

            var session = new CompileSession(
                compiler,
                text: "rule='add'/'mult';",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(5, 5)), // add
                            new Annotation(new EmptyRule(2), new(10, 1)), // operator /
                            new Annotation(new EmptyRule(1), new(11, 6))], // mult
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the sequence
                        new(new EmptyRule(evalId), new Range(1, 3), [
                            // add literal
                            new(new EmptyRule(literalId), new Range(1, 1)),
                            // mult literal
                            new(new EmptyRule(literalId), new Range(3, 1))
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize 'foo'
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(evalId, CompileEvaluation<char>)
                        .Compile<char>(session);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the evaluation as 'rule'
            var evalFunction = table.FindRule("rule") as MatchEvaluation<char>;
            
            IsNotNull(evalFunction);

            // the compiled table's root should be able to parse a foo OR bar string 
            var testInputs = new string[] { "add", "mult" };

            for (var i = 0; i < testInputs.Length; i++)
            {
                var testText = testInputs[i];
                var result = table.Root.Parse(testText.ToCharArray(), 0);

                // the result should hold a token which describes a eval spanning
                // the length of the test text
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == evalFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == testText.Length);

                // should have one child annotation which is the add literal
                IsNotNull(result.Annotations[0].Children);
                var literalChild = result.Annotations[0].Children[0];

                IsTrue(literalChild.Rule == evalFunction.RuleOptions[i]);
            }

        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a match count or its variants (*, +, ?)
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCountFunction()
        {
            TestRegisterAndCompileCountFunction(CompileZeroOrMore<char>, '*', 0, 0);
            TestRegisterAndCompileCountFunction(CompileOneOrMore<char>, '+', 1, 0);
            TestRegisterAndCompileCountFunction(CompileZeroOrOne<char>, '?', 0, 1);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a not rule
        /// </summary>
        [TestMethod]
        public void TestNotFunction()
        {
            var compiler = new RuleCompiler();

            var literalId = 42;
            var notId = 64;

            var context = new CompileSession(
                compiler,
                text: "rule=!'foo'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(2), new(4, 1)), // operatorChar
                            new Annotation(new EmptyRule(3), new(6, 5))], // foo

                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // not function
                        new (new EmptyRule(notId), new Range(1, 2),[
                            // foo literal
                            new(new EmptyRule(literalId), new Range(2, 1))
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize not 'foo'
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(notId, CompileNot<char>)
                        .Compile<char>(context);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var notFunction = table.FindRule("rule");
            IsNotNull(notFunction);

            var validInput = new string[] { "a", "", "_", "FoO", "fOo", "FOO", "fo" };
            var result = ParseResult.Failure;

            for (var i = 0; i < validInput.Length; i++)
            {
                result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a not foo
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == notFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == 0);
            }

            var invalidInput = "foo";
            
            result = table.Root.Parse(invalidInput.ToCharArray(), 0);
            IsFalse(result.FoundMatch);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a not rule
        /// </summary>
        [TestMethod]
        public void TestTryMatchFunction()
        {
            var compiler = new RuleCompiler();

            var literalId = 42;
            var tryMatchId = 64;

            var context = new CompileSession(
                compiler,
                text: "rule=try 'foo'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(2), new(5, 4)), // try match operator character
                            new Annotation(new EmptyRule(3), new(9, 5))], // foo
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // try match function
                        new (new EmptyRule(tryMatchId), new Range(1, 2),[
                            // foo literal
                            new(new EmptyRule(literalId), new Range(2, 1))
                        ])
                    ])
                ]
            );

            // compile a rule table which can tokenize try match 'foo'
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(tryMatchId, CompileTryMatch<char>)
                        .Compile<char>(context);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var tryMatch = table.FindRule("rule");
            IsNotNull(tryMatch);

            var validInput = "foo";
            var result = table.Root.Parse(validInput.ToCharArray(), 0);

            // the result should hold a token which describes a not foo
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == tryMatch);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == 0);

            var invalidInput = "bar";

            result = table.Root.Parse(invalidInput.ToCharArray(), 0);
            IsFalse(result.FoundMatch);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a any rule
        /// </summary>
        [TestMethod]
        public void TestAnyFunction()
        {
            var compiler = new RuleCompiler();

            var anyId = 64;

            var context = new CompileSession(
                compiler,
                text: "rule=.",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(4, 1))], // any
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // any function
                        new (new EmptyRule(anyId), new Range(1, 1))
                    ])
                ]);

            // compile a rule table which can tokenize 'any' char
            var table = compiler
                        .RegisterFunction(anyId, CompileAny<char>)
                        .Compile<char>(context);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var anyFunction = table.FindRule("rule");
            IsNotNull(anyFunction);

            var validInput = new string[] { "a", "b", "1", "_", "~" };
            var result = ParseResult.Failure;

            for (var i = 0; i < validInput.Length; i++)
            {
                result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a not foo
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == anyFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == 1);
            }

            var invalidInput = "";

            result = table.Root.Parse(invalidInput.ToCharArray(), 0);
            IsFalse(result.FoundMatch);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a log rule
        /// </summary>
        [TestMethod]
        public void SetUpCompileContext_Compile_ExpectValidLogRule()
        {
            var compiler = new RuleCompiler();

            var logId = 64;
            var literalId  = 128;
            var logLevelId = 256;

            var context = new CompileSession(
                compiler,
                text: "rule=debug 'message' if 'foo'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)),  // rule
                            new Annotation(new EmptyRule(1), new(5, 5)),  // log level
                            new Annotation(new EmptyRule(2), new(11, 9)), // message
                            new Annotation(new EmptyRule(3), new(21, 2)), // if
                            new Annotation(new EmptyRule(4), new(24, 5))  // match literal (condition)
                ],
                syntaxTree:  [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // error
                        new (new EmptyRule(logId), new Range(1, 3), [
                            new (new EmptyRule(logLevelId), new Range(1, 1)),    // log level
                            new (new EmptyRule(literalId), new Range(2, 1)),     // message
                            new (new EmptyRule(literalId), new Range(4, 1)),     // condition
                        ])
                    ])
                ]);

            // compile a rule table which can tokenize invoke an error
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(logId, CompileLog<char>)
                        .Compile<char>(context);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the error as 'rule'
            var logRule = table.FindRule("rule");
            IsTrue(logRule != null && logRule is LogRule<char>);

            var result = table.Root.Parse("foo".ToCharArray(), 0);

            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == logRule);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == "foo".Length);
        }

        private void TestRegisterAndCompileCountFunction(CompileFunction function, char operatorChar, int min, int max)
        {
            var compiler = new RuleCompiler();

            var literalId = 42;
            var countId = 64;

            var context = new CompileSession(
                compiler,
                text: $"rule={operatorChar}'foo'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(2), new(4, 1)), // operatorChar
                            new Annotation(new EmptyRule(3), new(6, 5))], // foo

                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // count function
                        new (new EmptyRule(countId), new Range(1, 2),[
                            // foo literal
                            new(new EmptyRule(literalId), new Range(2, 1))
                        ])
                    ])
                ]);

            // compile a rule table which can tokenize min-max x 'foo'
            var table = compiler
                        .RegisterFunction(literalId, CompileLiteral)
                        .RegisterFunction(countId, function)
                        .Compile<char>(context);

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var countFunction = table.FindRule("rule");
            IsNotNull(countFunction);

            var testText = "";
            var result = ParseResult.Failure;

            
            // zero input should yield a match, with 0 range
            result = table.Root.Parse(testText.ToCharArray(), 0);
            if (min == 0)
            {
                IsTrue(result.FoundMatch);
                IsTrue(result.MatchLength == 0);
            }
            else
            {
                IsFalse(result.FoundMatch);
            }

            for (var i = 0; i < min + 1; i++)
            {
                testText += "foo";
            }

            result = table.Root.Parse(testText.ToCharArray(), 0);
            
            IsTrue(result.FoundMatch);
            var expectedLength = max == 0 ? testText.Length : max * 3;
            IsTrue(result.MatchLength == expectedLength);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == countFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);

            if (max > 0)
            {
                testText = "";

                for (var i = 0; i < max + 1; i++)
                {
                    testText += "foo";
                }
                
                result = table.Root.Parse(testText.ToCharArray(), 0);

                IsTrue(result.FoundMatch);
                IsTrue(result.MatchLength == testText.Length - 3);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == countFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == max * 3);
            }
        }        
    }       
}
