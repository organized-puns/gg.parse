
using gg.parse.script.compiler;

using gg.parse.tests;

using static Microsoft.VisualStudio.TestTools.UnitTesting.Assert;

using static gg.parse.script.compiler.CompilerFunctions;

using Range = gg.parse.util.Range;

namespace gg.parse.script.tests.integration
{
    [TestClass]
    public class RuleCompilerTest
    {
        [TestMethod]
        public void CreateRuleWithTheSameName_Compile_ExpectException()
        {
            var litId = 42;
            var compiler = new RuleCompiler()
                    .RegisterFunction(litId, CompileLiteral);

            try
            {
                compiler.Compile<char>(
                    text: "rule='foo';rule='bar';",
                    // tokens normally generated by a tokenizer
                    tokens: [
                        // token which captures the rule name which runs in the text from 0-4 (rule)
                        new Annotation(new EmptyRule(0), new(0, 4)),

                        // token which captures the literal value in the text from 5-10 ('foo')
                        new Annotation(new EmptyRule(2), new(5, 5)),

                        // token which captures the rule name which runs in the text from 0-4 (rule)
                        new Annotation(new EmptyRule(0), new(11, 4)),

                        // token which captures the literal value in the text from 5-10 ('foo')
                        new Annotation(new EmptyRule(2), new(16, 5))
                    ],
                    // ast tree normally generated by a parser
                    // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                    syntaxTree: [
                        new Annotation(new EmptyRule(0), new(0, 2), [
                            // child capturing the token(s) defining the rule name
                            new (new EmptyRule(1), new Range(0, 1)), 

                            // child capturing the token(s) defining the literal
                            new (new EmptyRule(litId), new Range(1, 1))
                        ]),

                        new Annotation(new EmptyRule(2), new(2, 2), [
                            // child capturing the token(s) defining the rule name
                            new (new EmptyRule(1), new Range(2, 1)), 

                            // child capturing the token(s) defining the literal
                            new (new EmptyRule(litId), new Range(3, 1))
                        ])
                    ]
                );
                Fail();
            }
            catch (AggregateException ae)
            {
                IsTrue(ae.InnerExceptions.Count() == 1);
                IsTrue(ae.InnerExceptions.ElementAt(0) is CompilationException);
            }
        }


        [TestMethod]
        public void CreateRuleWithCustomPrecedence_Compile_ExpectRuleToHaveSamePrecedence()
        {
            var litId = 42;
            var rulePrecedence = 142;
            var compiler = new RuleCompiler()
                    .RegisterFunction(litId, CompileLiteral);

            var graph = compiler.Compile<char>(
                text: $"rule {rulePrecedence} = 'foo';",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    // token which captures the precedence value in the text from 5-8 (142)
                    new Annotation(new EmptyRule(1), new(5, 3)),

                    // token which captures the assignment operator in the text from 9-10 (=)
                    new Annotation(new EmptyRule(2), new(9, 1)),

                    // token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(new EmptyRule(3), new(11, 5))
                ],
                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree: [
                    new Annotation(new EmptyRule(0), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(1), new Range(0, 1)), 

                        // child capturing the token(s) defining the rule's precedence
                        new(new EmptyRule(2), new Range(1, 1)), 

                        // child capturing the token(s) defining the literal
                        new(new EmptyRule(litId), new Range(3, 1))
                    ])
                ]
            );

            IsNotNull(graph);
            IsNotNull(graph.Root);

            // the ebnf declared the literal as 'rule'
            var literalFunction = graph.FindRule("rule");

            IsNotNull(literalFunction);
            IsTrue(literalFunction.Precedence == rulePrecedence);
        }
    }
}
