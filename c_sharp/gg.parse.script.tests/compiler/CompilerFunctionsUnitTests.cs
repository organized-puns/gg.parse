
using gg.parse.rules;
using gg.parse.script.compiler;
using gg.parse.tests;

using static Microsoft.VisualStudio.TestTools.UnitTesting.Assert;

using static gg.parse.script.compiler.CompilerFunctions;

using Range = gg.parse.util.Range;
using gg.parse.core;

namespace gg.parse.script.tests.compiler
{
    /// <summary>
    /// Test the various compiler functions.
    /// </summary>
    [TestClass]
    public class CompilerFunctionsUnitTests
    {
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a literal 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileLiteral()
        {
            var litRule = new EmptyRule(42);
            var compiler = new RuleCompiler().MapRuleToCompilerFunction(litRule, CompileLiteral);

            // compile a rule table which can tokenize 'foo'
            var table = compiler.Compile<char>(
                text: "rule='foo'",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),
                    
                    //token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(new EmptyRule(1), new(5, 5))
                ],
                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the literal
                        new(litRule, new Range(1, 1))
                    ])
                ]
            );
            

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var literalFunction = table.FindRule("rule");

            IsNotNull(literalFunction);

            // the compiled table's root should be able to parse a foo string 
            var validInput = "foo";
            var result = table.Root.Parse(validInput.ToCharArray(), 0);

            // the result should hold a token which describes a literal spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == literalFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == validInput.Length);

            var invalidInput = new string[] { "bar", "Foo", "f", "fo", "" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a character set 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCharacterSet()
        {
            var setId = new EmptyRule(42);
            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(setId, CompileCharacterSet);

            var table = compiler.Compile<char>(
                text: "rule={'abc'}",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    //token which captures the set value in the text from 5-10 ('foo')
                    new Annotation(new EmptyRule(1), new(6, 5))
                ],
                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the sequence of set {'abc'}
                        new(setId, new Range(1, 1), [
                            // token(s) defining the set literal 'abc'
                            new(new EmptyRule(1), new Range(1, 1))
                        ])
                    ])
                ]
            );

            
            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the set rule as 'rule'
            var setFunction = table.FindRule("rule");

            IsNotNull(setFunction);

            // the compiled table's root should be able to parse a foo string 
            var validInput = new string[] { "a", "b", "c" };
            for (var i = 0; i < validInput.Length; i++)
            {
                var result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a character in the set abc spanning
                // the length of the test text
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == setFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }

            // should not match any of these
            var invalidInput = new string[] { "A", "1", "_" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                var result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                IsFalse(result.FoundMatch);
            }
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a character range 
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCharacterRange()
        {
            var rangeId = new EmptyRule(42);
            var compiler = new RuleCompiler()
                   .MapRuleToCompilerFunction(rangeId, CompileCharacterRange);
            
            // compile a rule table which can tokenize a character in the set of 'abc'
            var table = compiler.Compile<char>(
                text: "rule='a'..'e'",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    //token which captures the range value in the text from 5-8 ('a')
                    new Annotation(new EmptyRule(1), new(5, 3)),

                    //token which captures the range value in the text from 10-13 ('e')
                    new Annotation(new EmptyRule(1), new(10, 3))
                ],

                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and range)
                 syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the literal
                        new(rangeId, new Range(1, 2), [
                            // min
                            new(rangeId, new Range(1, 1)),
                            // max
                            new(rangeId, new Range(2, 1)),
                        ])
                    ])
                ]
            );

            
            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the range rule as 'rule'
            var rangeRule = table.FindRule("rule");

            IsNotNull(rangeRule);

            // the compiled table's root should be able to parse any char in the range a..e 
            var validInput = new string[] { "a", "b", "c", "d", "e" };
            for (var i = 0; i < validInput.Length; i++)
            {
                var result = table.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a character in the set abc spanning
                // the length of the test text
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == rangeRule);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == validInput[i].Length);
            }

            // should not match any of these
            var invalidInput = new string[] { "A", "f", "1", "" };

            for (var i = 0; i < invalidInput.Length; i++)
            {
                var result = table.Root.Parse(invalidInput[i].ToCharArray(), 0);
                IsFalse(result.FoundMatch);
            }
        }
        
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an identifier
        /// </summary>
        [TestMethod]
        public void TestCompileIdentifier()
        {
            var indentifierId = new EmptyRule(42);
            var compiler = new RuleCompiler()
                    .MapRuleToCompilerFunction(indentifierId, CompileIdentifier<char>);

            var table = new RuleGraph<char>();

            // insert a foo rule for reference to which the compiled rule refers
            // this foo parses a literal bar
            table.RegisterRule(new MatchDataSequence<char>("foo", [.. "bar"]));

            var context = compiler.Compile(
                text: "rule=foo",

                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    //token which captures the identifier value in the text from 5-10 ('foo')
                    new Annotation(new EmptyRule(1), new(5, 3))
                ],

                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the identifier 
                        new(indentifierId, new Range(1, 1), [
                            // no output annotation, therefore defaults to annotation
                            // identifier name
                            new (new EmptyRule(0), new Range(1,1))
                        ])
                    ])
                ],
                table
            );

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var identifierRule = table.FindRule("rule");

            IsNotNull(identifierRule);

            // the compiled table's root should be able to parse a bar string 
            var testText = "bar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes an identifier spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == identifierRule);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);
        }
        
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an identifier
        /// with an explicit product
        /// </summary>
        [TestMethod]
        public void TestCompileIdentifierWithProduct()
        {
            var indentifierId = new EmptyRule(42);
            var noneProductId = 62;

            var compiler = new RuleCompiler([(noneProductId, AnnotationPruning.All)])
                .MapRuleToCompilerFunction(indentifierId, CompileIdentifier<char>);

            // compile a rule table which can tokenize foo
            var table = new RuleGraph<char>();

            // insert a foo rule for reference to which the compiled rule refers
            // this foo parses a literal bar
            table.RegisterRule(new MatchDataSequence<char>("foo", [.. "bar"]));

            var context = compiler.Compile(
                text: "rule=-a foo",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    // token which captures the pruning which runs in the text from 5-1 (rule)
                    new Annotation(new EmptyRule(0), new(5, 3)),
                    
                    //token which captures the identifier value in the text from 6-9 ('foo')
                    new Annotation(new EmptyRule(1), new(8, 3))
                ],

                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree:  [
                    new Annotation(new EmptyRule(2), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the token(s) defining the literal
                        new(indentifierId, new Range(1, 2), [
                            // output
                            new (new EmptyRule(noneProductId), new Range(1,1)),
                            // name
                            new (new EmptyRule(2), new Range(2,1)),
                        ])
                    ])
                ],
                table
            );

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the literal as 'rule'
            var identifierRule = table.FindRule("rule") as RuleReference<char>;

            IsNotNull(identifierRule);
            IsTrue(identifierRule.ReferencePrune == AnnotationPruning.All);

            // the compiled table's root should be able to parse a bar string 
            var testText = "bar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // 
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations[0] == "rule");
            IsTrue(result.Annotations[0].Count == 0);
        }

        
        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a group 
        /// consisting of a sequence of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileGroup()
        {

            var literalId = new EmptyRule(42);
            var sequenceId = new EmptyRule(64);
            var groupId = new EmptyRule(128);

            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(literalId, CompileLiteral)
                .MapRuleToCompilerFunction(sequenceId, CompileSequence<char>)
                .MapRuleToCompilerFunction(groupId, CompileGroup<char>);
            

            var  table = compiler.Compile<char>(
                text: "rule=('foo','bar')",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(6, 5)), // foo
                            new Annotation(new EmptyRule(1), new(12, 5))], // bar

                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // group
                        new (groupId, new Range(1, 2),[
                            // child capturing the sequence
                            new(sequenceId, new Range(1, 2), [
                                // foo literal
                                new(literalId, new Range(1, 1)),
                                // bar literal
                                new(literalId, new Range(2, 1))
                            ])
                        ])
                    ])
                ]
            );

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var groupFunction = table.FindRule("rule");

            IsNotNull(groupFunction);

            // the compiled table's root should be able to parse a foobar string 
            var testText = "foobar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == groupFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing a sequence
        /// of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileSequence()
        {
            var literalId = new EmptyRule(42);
            var sequenceId = new EmptyRule(64);

            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(literalId, CompileLiteral)
                .MapRuleToCompilerFunction(sequenceId, CompileSequence<char>);

            var table = compiler.Compile<char>(
                text: "rule='foo','bar'",
                tokens : [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(5, 5)), // foo
                            new Annotation(new EmptyRule(1), new(11, 5))], // bar
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the sequence
                        new(sequenceId, new Range(1, 2), [
                            // foo literal
                            new(literalId, new Range(1, 1)),
                            // bar literal
                            new(literalId, new Range(2, 1))
                        ])
                    ])
                ]
            );

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var sequenceFunction = table.FindRule("rule");

            IsNotNull(sequenceFunction);

            // the compiled table's root should be able to parse a foobar string 
            var testText = "foobar";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == sequenceFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an option
        /// of literals
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileOption()
        {
            var literalId = new EmptyRule(42);
            var optionId = new EmptyRule(64);

            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(literalId, CompileLiteral)
                .MapRuleToCompilerFunction(optionId, CompileOption<char>);

            var table = compiler.Compile<char>(
                text: "rule='foo'|'bar'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(5, 5)), // foo
                            new Annotation(new EmptyRule(1), new(11, 5))], // bar
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the sequence
                        new(optionId, new Range(1, 2), [
                            // foo literal
                            new(literalId, new Range(1, 1)),
                            // bar literal
                            new(literalId, new Range(2, 1))
                        ])
                    ])
                ]
            );

            IsNotNull(table);
            IsNotNull(table.Root);

            // the ebnf declared the sequence as 'rule'
            var optionFunction = table.FindRule("rule");

            IsNotNull(optionFunction);

            // the compiled table's root should be able to parse a foo OR bar string 
            var testText = "foo";
            var result = table.Root.Parse(testText.ToCharArray(), 0);

            // the result should hold a token which describes a sequence spanning
            // the length of the test text
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == optionFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);

            // do the same test with bar
            testText = "bar";
            result = table.Root.Parse(testText.ToCharArray(), 0);
            
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == optionFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing an evaluation
        /// of literals (which is non-sensical but serves the purpose of the test)
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileSingleUnaryEvaluation()
        {
            var literalId = new EmptyRule(42);
            var evalId = new EmptyRule(64);

            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(literalId, CompileLiteral)
                .MapRuleToCompilerFunction(evalId, CompileEvaluation<char>);

            var graph = compiler.Compile<char>(
                text: "rule='add'/'mult';",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(5, 5)), // add
                            new Annotation(new EmptyRule(2), new(10, 1)), // operator /
                            new Annotation(new EmptyRule(1), new(11, 6))], // mult
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // child capturing the sequence
                        new(evalId, new Range(1, 3), [
                            // add literal
                            new(literalId, new Range(1, 1)),
                            // mult literal
                            new(literalId, new Range(3, 1))
                        ])
                    ])
                ]
            );

            IsNotNull(graph);
            IsNotNull(graph.Root);

            // the ebnf declared the evaluation as 'rule'
            var evalFunction = graph.FindRule("rule") as MatchEvaluation<char>;
            
            IsNotNull(evalFunction);

            // the compiled table's root should be able to parse a foo OR bar string 
            var testInputs = new string[] { "add", "mult" };

            for (var i = 0; i < testInputs.Length; i++)
            {
                var testText = testInputs[i];
                var result = graph.Root.Parse(testText.ToCharArray(), 0);

                // the result should hold a token which describes a eval spanning
                // the length of the test text
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == evalFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == testText.Length);

                // should have one child annotation which is the add literal
                IsNotNull(result.Annotations[0].Children);
                var literalChild = result.Annotations[0].Children[0];

                IsTrue(literalChild.Rule == evalFunction.RuleOptions[i]);
            }

        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a match count or its variants (*, +, ?)
        /// </summary>
        [TestMethod]
        public void TestRegisterAndCompileCountFunction()
        {
            TestRegisterAndCompileCountFunction(CompileZeroOrMore<char>, '*', 0, 0);
            TestRegisterAndCompileCountFunction(CompileOneOrMore<char>, '+', 1, 0);
            TestRegisterAndCompileCountFunction(CompileZeroOrOne<char>, '?', 0, 1);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a not rule
        /// </summary>
        [TestMethod]
        public void TestNotFunction()
        {
            var literalId = new EmptyRule(42);
            var notId = new EmptyRule(64);

            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(literalId, CompileLiteral)
                .MapRuleToCompilerFunction(notId, CompileNot<char>);

            var graph = compiler.Compile<char>(
                text: "rule=!'foo'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(2), new(4, 1)), // operatorChar
                            new Annotation(new EmptyRule(3), new(6, 5))], // foo

                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // not function
                        new (notId, new Range(1, 2),[
                            // foo literal
                            new(literalId, new Range(2, 1))
                        ])
                    ])
                ]
            );

            
            IsNotNull(graph);
            IsNotNull(graph.Root);

            // the ebnf declared the sequence as 'rule'
            var notFunction = graph.FindRule("rule");
            IsNotNull(notFunction);

            var validInput = new string[] { "a", "", "_", "FoO", "fOo", "FOO", "fo" };
            var result = ParseResult.Failure;

            for (var i = 0; i < validInput.Length; i++)
            {
                result = graph.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a not foo
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == notFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == 0);
            }

            var invalidInput = "foo";
            
            result = graph.Root.Parse(invalidInput.ToCharArray(), 0);
            IsFalse(result.FoundMatch);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a not rule
        /// </summary>
        [TestMethod]
        public void TestTryMatchFunction()
        {
            var literalId = new EmptyRule(42);
            var tryMatchId = new EmptyRule(64);

            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(literalId, CompileLiteral)
                .MapRuleToCompilerFunction(tryMatchId, CompileTryMatch<char>);

            var graph = compiler.Compile<char>(
                text: "rule=try 'foo'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(2), new(5, 4)), // try match operator character
                            new Annotation(new EmptyRule(3), new(9, 5))], // foo
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // try match function
                        new (tryMatchId, new Range(1, 2),[
                            // foo literal
                            new(literalId, new Range(2, 1))
                        ])
                    ])
                ]
            );

            IsNotNull(graph);
            IsNotNull(graph.Root);

            // the ebnf declared the sequence as 'rule'
            var tryMatch = graph.FindRule("rule");
            IsNotNull(tryMatch);

            var validInput = "foo";
            var result = graph.Root.Parse(validInput.ToCharArray(), 0);

            // the result should hold a token which describes a not foo
            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == tryMatch);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == 0);

            var invalidInput = "bar";

            result = graph.Root.Parse(invalidInput.ToCharArray(), 0);
            IsFalse(result.FoundMatch);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a any rule
        /// </summary>
        [TestMethod]
        public void TestAnyFunction()
        {
            var anyId = new EmptyRule(64);
            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(anyId, CompileAny<char>);

            var graph = compiler.Compile<char>(
                text: "rule=.",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(1), new(4, 1))], // any
                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // any function
                        new (anyId, new Range(1, 1))
                    ])
                ]);


            IsNotNull(graph);
            IsNotNull(graph.Root);

            // the ebnf declared the sequence as 'rule'
            var anyFunction = graph.FindRule("rule");
            IsNotNull(anyFunction);

            var validInput = new string[] { "a", "b", "1", "_", "~" };
            var result = ParseResult.Failure;

            for (var i = 0; i < validInput.Length; i++)
            {
                result = graph.Root.Parse(validInput[i].ToCharArray(), 0);

                // the result should hold a token which describes a not foo
                IsTrue(result.FoundMatch);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == anyFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == 1);
            }

            var invalidInput = "";

            result = graph.Root.Parse(invalidInput.ToCharArray(), 0);
            IsFalse(result.FoundMatch);
        }

        /// <summary>
        /// Tests & demonstrates how to generate a ruletable using a compiler containing 
        /// a log rule
        /// </summary>
        [TestMethod]
        public void SetUpCompileContext_Compile_ExpectValidLogRule()
        {
            var logId = new EmptyRule(64);
            var literalId = new EmptyRule(128);
            var logLevelId = new EmptyRule(256);

            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(literalId, CompileLiteral)
                .MapRuleToCompilerFunction(logId, CompileLog<char>);

            var graph = compiler.Compile<char>(
                text: "rule=debug 'message' if 'foo'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)),  // rule
                            new Annotation(new EmptyRule(1), new(5, 5)),  // log level
                            new Annotation(new EmptyRule(2), new(11, 9)), // message
                            new Annotation(new EmptyRule(3), new(21, 2)), // if
                            new Annotation(new EmptyRule(4), new(24, 5))  // match literal (condition)
                ],
                syntaxTree:  [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // error
                        new (logId, new Range(1, 3), [
                            new (logLevelId, new Range(1, 1)),    // log level
                            new (literalId, new Range(2, 1)),     // message
                            new (literalId, new Range(4, 1)),     // condition
                        ])
                    ])
                ]);

            IsNotNull(graph);
            IsNotNull(graph.Root);

            // the ebnf declared the error as 'rule'
            var logRule = graph.FindRule("rule");
            IsTrue(logRule != null && logRule is LogRule<char>);

            var result = graph.Root.Parse("foo".ToCharArray(), 0);

            IsTrue(result.FoundMatch);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == logRule);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == "foo".Length);
        }

        [TestMethod]
        public void CreateRuleWithTheSameName_Compile_ExpectException()
        {
            var litId = new EmptyRule(42);
            var compiler = new RuleCompiler()
                    .MapRuleToCompilerFunction(litId, CompileLiteral);

            try
            {
                compiler.Compile<char>(
                    text: "rule='foo';rule='bar';",
                    // tokens normally generated by a tokenizer
                    tokens: [
                        // token which captures the rule name which runs in the text from 0-4 (rule)
                        new Annotation(new EmptyRule(0), new(0, 4)),

                        // token which captures the literal value in the text from 5-10 ('foo')
                        new Annotation(new EmptyRule(2), new(5, 5)),

                        // token which captures the rule name which runs in the text from 0-4 (rule)
                        new Annotation(new EmptyRule(0), new(11, 4)),

                        // token which captures the literal value in the text from 5-10 ('foo')
                        new Annotation(new EmptyRule(2), new(16, 5))
                    ],
                    // ast tree normally generated by a parser
                    // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                    syntaxTree: [
                        new Annotation(new EmptyRule(0), new(0, 2), [
                            // child capturing the token(s) defining the rule name
                            new (new EmptyRule(1), new Range(0, 1)), 

                            // child capturing the token(s) defining the literal
                            new (litId, new Range(1, 1))
                        ]),

                        new Annotation(new EmptyRule(2), new(2, 2), [
                            // child capturing the token(s) defining the rule name
                            new (new EmptyRule(1), new Range(2, 1)), 

                            // child capturing the token(s) defining the literal
                            new (litId, new Range(3, 1))
                        ])
                    ]
                );
                Fail();
            }
            catch (AggregateException ae)
            {
                IsTrue(ae.InnerExceptions.Count == 1);
                IsTrue(ae.InnerExceptions.ElementAt(0) is CompilationException);
            }
        }


        [TestMethod]
        public void CreateRuleWithCustomPrecedence_Compile_ExpectRuleToHaveSamePrecedence()
        {
            var litId = new EmptyRule(42);
            var rulePrecedence = 142;
            var compiler = new RuleCompiler()
                    .MapRuleToCompilerFunction(litId, CompileLiteral);

            var graph = compiler.Compile<char>(
                text: $"rule {rulePrecedence} = 'foo';",
                // tokens normally generated by a tokenizer
                tokens: [
                    // token which captures the rule name which runs in the text from 0-4 (rule)
                    new Annotation(new EmptyRule(0), new(0, 4)),

                    // token which captures the precedence value in the text from 5-8 (142)
                    new Annotation(new EmptyRule(1), new(5, 3)),

                    // token which captures the assignment operator in the text from 9-10 (=)
                    new Annotation(new EmptyRule(2), new(9, 1)),

                    // token which captures the literal value in the text from 5-10 ('foo')
                    new Annotation(new EmptyRule(3), new(11, 5))
                ],
                // ast tree normally generated by a parser
                // the ast tree with one rule capturing the token 0-2 (ruleName and litToken)
                syntaxTree: [
                    new Annotation(new EmptyRule(0), new(0, 2), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(1), new Range(0, 1)), 

                        // child capturing the token(s) defining the rule's precedence
                        new(new EmptyRule(2), new Range(1, 1)), 

                        // child capturing the token(s) defining the literal
                        new(litId, new Range(3, 1))
                    ])
                ]
            );

            IsNotNull(graph);
            IsNotNull(graph.Root);

            // the ebnf declared the literal as 'rule'
            var literalFunction = graph.FindRule("rule");

            IsNotNull(literalFunction);
            IsTrue(literalFunction.Precedence == rulePrecedence);
        }

        private static void TestRegisterAndCompileCountFunction(CompileFunction function, char operatorChar, int min, int max)
        {
            var literalId = new EmptyRule(42);
            var countId = new EmptyRule(64);

            var compiler = new RuleCompiler()
                .MapRuleToCompilerFunction(literalId, CompileLiteral)
                .MapRuleToCompilerFunction(countId, function);

            var graph = compiler.Compile<char>(
                text: $"rule={operatorChar}'foo'",
                tokens: [new Annotation(new EmptyRule(0), new(0, 4)), // rule
                            new Annotation(new EmptyRule(2), new(4, 1)), // operatorChar
                            new Annotation(new EmptyRule(3), new(6, 5))], // foo

                syntaxTree: [
                    new Annotation(new EmptyRule(2), new(0, 3), [
                        // child capturing the token(s) defining the rule name
                        new(new EmptyRule(0), new Range(0, 1)), 

                        // count function
                        new (countId, new Range(1, 2),[
                            // foo literal
                            new(literalId, new Range(2, 1))
                        ])
                    ])
                ]);

            IsNotNull(graph);
            IsNotNull(graph.Root);

            // the ebnf declared the sequence as 'rule'
            var countFunction = graph.FindRule("rule");
            IsNotNull(countFunction);

            var testText = "";
            var result = ParseResult.Failure;

            
            // zero input should yield a match, with 0 range
            result = graph.Root.Parse(testText.ToCharArray(), 0);
            if (min == 0)
            {
                IsTrue(result.FoundMatch);
                IsTrue(result.MatchLength == 0);
            }
            else
            {
                IsFalse(result.FoundMatch);
            }

            for (var i = 0; i < min + 1; i++)
            {
                testText += "foo";
            }

            result = graph.Root.Parse(testText.ToCharArray(), 0);
            
            IsTrue(result.FoundMatch);
            var expectedLength = max == 0 ? testText.Length : max * 3;
            IsTrue(result.MatchLength == expectedLength);
            IsTrue(result.Annotations != null);
            IsTrue(result.Annotations.Count == 1);
            IsTrue(result.Annotations[0].Rule == countFunction);
            IsTrue(result.Annotations[0].Start == 0);
            IsTrue(result.Annotations[0].Length == testText.Length);

            if (max > 0)
            {
                testText = "";

                for (var i = 0; i < max + 1; i++)
                {
                    testText += "foo";
                }
                
                result = graph.Root.Parse(testText.ToCharArray(), 0);

                IsTrue(result.FoundMatch);
                IsTrue(result.MatchLength == testText.Length - 3);
                IsTrue(result.Annotations != null);
                IsTrue(result.Annotations.Count == 1);
                IsTrue(result.Annotations[0].Rule == countFunction);
                IsTrue(result.Annotations[0].Start == 0);
                IsTrue(result.Annotations[0].Length == max * 3);
            }
        }        
    }       
}
